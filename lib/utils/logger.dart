import 'dart:collection';
import 'package:logging/logging.dart';
import 'package:logging_appenders/logging_appenders.dart';
import 'package:bc4f/utils/app-status.dart';

Logger get log => _log ?? initLog();
Logger _log;

Logger initLog() {
  _log = Logger('BC4F');
  Logger.root.clearListeners();

  AppStatus().consoleLog.attachToLogger(Logger.root);
  return _log;
}

void disposeAppenders() {
  if (AppStatus().consoleLog != null) AppStatus().consoleLog.dispose();
}

class LogPrinter extends LogRecordFormatter {
  static const Map<int, String> _mapLevel = {
    300: '👁', // FINEST
    400: '🕸', // FINER
    500: '🐛', // FINE
    700: '🛠', // CONFIG
    800: '🚀', // INFO
    900: '🔥', // WARNING
    1000: '🧨', // SEVERE
    1200: '📣', // SHOUT
  };
  static const String FALLBACK_ICO = '';
  final int methodCount;
  final int errorMethodCount;

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #1      Logger.log (package:logger/src/logger.dart:115:29)
  static final _deviceStackTraceRegex =
      RegExp(r'#[0-9]+[\s]+(.+) \(([^\s]+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex =
      RegExp(r'^((packages|dart-sdk)\/[^\s]+\/)');

  LogPrinter({this.methodCount = 8, this.errorMethodCount = 12});

  StringBuffer formatToStringBuffer(LogRecord rec, StringBuffer sb) {
    String stackTraceStr;
    if (rec.stackTrace == null) {
      if (methodCount > 0) {
        stackTraceStr =
            formatStackTrace(StackTrace.current, methodCount, skipFirst: 14);
      }
    } else if (errorMethodCount > 0) {
      stackTraceStr = formatStackTrace(rec.stackTrace, errorMethodCount);
    }
    String time = DateTime.now().toIso8601String().replaceFirst('T', ' ');
    final level = _mapLevel[rec.level.value] ??
        FALLBACK_ICO; //rec.level.name.toUpperCase();

    if (rec.level == Level.SHOUT) {
      // SHOUT no stacktrace, datetime expanded
    } else if (rec.level == Level.WARNING) {
      // WARNING no stacktrace, short time
      time = time.substring(11, 19);
    } else if (rec.level == Level.SEVERE) {
      // SEVERE with stacktrace, datetime expanded
      sb.writeln('----------------------------------------------------------');
      sb.writeln(stackTraceStr);
    } else if (rec.level == Level.INFO) {
      // INFO no stacktrace, short time
      time = time.substring(11, 19);
    } else if (rec.level == Level.CONFIG) {
      // CONFIG no stacktrace, short time
      time = time.substring(11, 19);
    } else if (rec.level == Level.FINE) {
      // FINE no stacktrace, short time
      time = time.substring(11, 19);
    } else if (rec.level == Level.FINER) {
      // FINER no stacktrace, short time
      time = time.substring(11, 19);
    } else if (rec.level == Level.FINEST) {
      // FINEST with stacktrace, datetime expanded
      sb.writeln('----------------------------------------------------------');
      sb.writeln(stackTraceStr);
    } else {
      // OTHER no stacktrace, short time
      time = time.substring(11, 19);
    }
    final printedFromLine = StackTrace.current.toString().split('\n')[14];
    final method = printedFromLine.replaceFirst(RegExp(r'#\d+\s+'), '');

    final concatLog = '$time $level ${rec.message}';
    sb.writeln(method);
    sb.writeln(concatLog);
    return sb;
  }

  String formatStackTrace(StackTrace stackTrace, int methodCount,
      {int skipFirst}) {
    var lines = stackTrace.toString().split('\n');
    if (skipFirst != null && skipFirst > 0) {
      lines = lines.sublist(skipFirst);
    }
    var formatted = <String>[];
    var count = 0;
    //rimuovo le prime righe dello stack trace del logger stesso
    final startIdx =
        1 + lines.lastIndexWhere((e) => e.contains('packages/logging'));
    lines.removeRange(0, startIdx);
    for (var line in lines) {
      if (_discardDeviceStacktraceLine(line) ||
          _discardWebStacktraceLine(line)) {
        continue;
      }
      formatted.add('#$count   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
      if (++count == methodCount) {
        break;
      }
    }

    if (formatted.isEmpty) {
      return null;
    } else {
      return formatted.join('\n');
    }
  }

  bool _discardDeviceStacktraceLine(String line) {
    var match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(2).startsWith('package:logger');
  }

  bool _discardWebStacktraceLine(String line) {
    var match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1).startsWith('packages/logger') ||
        match.group(1).startsWith('dart-sdk/lib');
  }
}

class MemoryAppender extends BaseLogAppender {
  final ListQueue<String> _queue;
  final int bufferSize;

  ListQueue<String> get log => _queue;

  MemoryAppender({LogRecordFormatter formatter, this.bufferSize = 100})
      : _queue = ListQueue(bufferSize),
        super(formatter);

  @override
  void handle(LogRecord record) {
    if (_queue.length == bufferSize) {
      _queue.removeFirst();
    }
    _queue.add(formatter.format(record));
  }
}
